{"meta":{"title":"Notes","subtitle":"","description":"好记性不如烂笔头。","author":"Yang","url":"http://www.yq194.top"},"pages":[{"title":"","date":"2018-01-02T09:14:21.000Z","updated":"2017-01-24T06:50:16.000Z","comments":true,"path":"404.html","permalink":"http://www.yq194.top/404.html","excerpt":"","text":"404"},{"title":"","date":"2017-01-24T07:28:01.000Z","updated":"2017-04-08T05:58:28.000Z","comments":true,"path":"about/index.html","permalink":"http://www.yq194.top/about/index.html","excerpt":"","text":"据我们所知，我们已经知道一些，我们知道我们已经知道一些，我们还知道，我们有些并不知道，也就是说，我们知道有些事情我们还不知道，但是，还有一些，我们并不知道我们不知道，这些我们不知道的，我们不知道 Mr’ Yang"},{"title":"分类","date":"2018-01-03T08:39:27.000Z","updated":"2018-01-03T08:39:27.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.yq194.top/categories/index.html","excerpt":"","text":""},{"title":"常用标签","date":"2018-01-03T08:40:36.000Z","updated":"2018-01-03T08:40:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.yq194.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java集合之 LinkedList 笔记","slug":"Java集合之-LinkedList-笔记","date":"2018-01-02T07:03:18.000Z","updated":"2018-01-04T02:36:21.000Z","comments":true,"path":"2018/01/02/Java集合之-LinkedList-笔记/","link":"","permalink":"http://www.yq194.top/2018/01/02/Java集合之-LinkedList-笔记/","excerpt":"1. LinkedList概述及层次结构(JDK1.8.0_131): LinkedList的继承体系中有List接口，Queue接口和Deque接口(double ended queue),表示明了LinkedList既能当作链表又能当作队列(Queue)还能当作栈(Stack);FIFO,LIFO及顺序访问都可以满足，虽然JDK中有Stack(继承自Vector),但官方推荐使用ArrayDeque. LinkedList底层采用双向链表(prev头节点，next尾节点)，元素可以为null,空链表时prev=next=null. LinkedList线程不安全,可以使用Collections.synchronizedList(List list)进行包装. LinkedList插入，删除操作常数时间，顺序访问线性时间.","text":"1. LinkedList概述及层次结构(JDK1.8.0_131): LinkedList的继承体系中有List接口，Queue接口和Deque接口(double ended queue),表示明了LinkedList既能当作链表又能当作队列(Queue)还能当作栈(Stack);FIFO,LIFO及顺序访问都可以满足，虽然JDK中有Stack(继承自Vector),但官方推荐使用ArrayDeque. LinkedList底层采用双向链表(prev头节点，next尾节点)，元素可以为null,空链表时prev=next=null. LinkedList线程不安全,可以使用Collections.synchronizedList(List list)进行包装. LinkedList插入，删除操作常数时间，顺序访问线性时间. 1234// 来自于源码JDK1.8.0_131public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 2. LinkedList源码解析(JDK1.8.0_131): 只列出一些比较常用的操作和部分方法解析 2.1 属性及定义: 12345678910111213141516171819202122232425262728293031323334//链表长度(节点数量)transient int size = 0;//头节点transient Node&lt;E&gt; first;//尾节点transient Node&lt;E&gt; last;//内部节点类private static class Node&lt;E&gt; &#123; //节点元素 E item; //指定上一节点 Node&lt;E&gt; next; //指向下一节点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;//构造方法:空链表 public LinkedList() &#123;&#125;//构造方法:以集合作为初始链表public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 2.1 几个基本操作所用到的方法源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** 往链表屁股后添加元素*/void linkLast(E e) &#123; //用临时变量l指向尾节点 final Node&lt;E&gt; l = last; //以l作为头节点，e为元素创建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //将尾节点指向新节点 last = newNode; //如果是空链表，first=next=新节点 if (l == null) first = newNode; else //否则把原来尾节点的next指向新节点，以确保双链不断 l.next = newNode; //链表长度增加 size++; //修改标记变量增加 modCount++;&#125;/* * 在链表头插入一个元素为e的节点 */ private void linkFirst(E e) &#123; //临时变量f指向头节点 final Node&lt;E&gt; f = first; //以元素e为尾节点创建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //头节点指向新节点 first = newNode; //如果是空链，头尾都指向新节点 if (f == null) last = newNode; else //否则原来的头节点的前一节点指向新节点，保证双链不断 f.prev = newNode; size++; modCount++;&#125;//在非null节点succ前插入元素为e的新节点void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null;succ的前驱节点 final Node&lt;E&gt; pred = succ.prev; //构造新节点，前驱pred,后继succ final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //设置succ的前驱 succ.prev = newNode; //如果前驱pred为空，表示原来succ=first if (pred == null) //现在first = newNode first = newNode; else //否则设置前驱pred的后继节点 pred.next = newNode; size++; modCount++;&#125;/** * 解除非空头节点f，返回f的值 */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null;返回元素 final E element = f.item; //后继节点 final Node&lt;E&gt; next = f.next; //item引用指向null,帮助GC f.item = null; //f节点的next引用指向null,帮助GC f.next = null; // help GC //链表头节点指向f的后继节点 first = next; //如果后继节点为空，链表尾节点设置为null if (next == null) last = null; else //否则把后继节点的前驱与f断开(未删除时本来指向f） next.prev = null; size--; modCount++; return element;&#125;/** * 解除链表的非空尾节点l,返回节点l的值 */private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null;尾节点元素值 final E element = l.item; //拿到l的前驱prev final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC //把链表尾节点指向prev last = prev; //如果prev为null表示删除l后链表空了 if (prev == null) //first指向null first = null; else //否则把prev的后继置为空 prev.next = null; size--; modCount++; return element;&#125;/** * 解除非空节点x，返回x节点的值 */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; //后继 final Node&lt;E&gt; next = x.next; //前驱 final Node&lt;E&gt; prev = x.prev; //x的前驱为空，链表头节点first指向x的后继 if (prev == null) &#123; first = next; &#125; else &#123; //否则前驱的后继指向x的后继next prev.next = next; x.prev = null; &#125; //x的后继为空，链表的尾节点last指向prev if (next == null) &#123; last = prev; &#125; else &#123; //否则x的后继的前驱指向prev next.prev = prev; //x的后继指向空,help gc x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; (1).addFirst()操作 1234public void addFirst(E e) &#123; //见上面的linkFirst源码 linkFirst(e);&#125; (2).addLast()操作 1234public void addLast(E e) &#123; //如上linkLast源码 linkLast(e);&#125; (3).remove()和remove(int index)操作 123456789101112131415161718192021222324252627/** * 这里遍历链表时区分null和非null值的查找，删除链表中第一个查到的节点 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; //使用unlink unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; 删除中间元素 (4).add(int index,E element)操作 12345678910public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) //见上面源码 linkLast(element); else //见上面源码 linkBefore(element, node(index));&#125; (5).get和set操作 12345678910111213141516171819202122232425262728293031//get,set 操作需要check index操作//get操作public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; //set操作public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; (5).indexof()操作 1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; 3. 总结: 从LinkedList中的层次结构来看，既有Deque又有Queue,而本篇是以实现List的双向链表来看源码，后面会有用Deque和Queue对比来看LinkedList。实现list,Deque和Queue的方法如下: LinkedList的set,get方法需要从尾或从头遍历链表[if (index &lt; (size &gt;&gt; 1))],add,addLast,addFirst,remove操作都非常快. Apache(org.apache.commons)下有一个TreeList底层用树来实现快速移动指针来达到快速查找的功能,时间复杂度O(log n),但占用内存大。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://www.yq194.top/tags/Java集合/"}]},{"title":"Java集合之 ArrayList 笔记","slug":"Java集合之-ArrayList-笔记","date":"2017-12-27T09:50:06.000Z","updated":"2018-01-04T02:36:10.000Z","comments":true,"path":"2017/12/27/Java集合之-ArrayList-笔记/","link":"","permalink":"http://www.yq194.top/2017/12/27/Java集合之-ArrayList-笔记/","excerpt":"1. ArrayList概述及层次结构(JDK1.8.0_131): ArrayList的底层是对象数组Object[]，可存储null 未指定初始化大小的默认容量大小是10，超过指定容量后ArrayList采用自动扩容，容量为原来的1.5倍(也就是增加了原来的50%)，1.5倍不大不小刚好，2，2.5。。。都会占用内存大 ArrayList的扩容采用的System.arraycopy()进行复制; 底层是数组决定的查找快，增删慢的特性。get（i），set（i，e） 的性能很高，而remove(i,e)，add(i,e)时需要通过System.arraycopy()复制来达移动数组的目的; ArrayList是非线程安全的，需要同步情况下可在构造时生成同步的List实例或采用java.util.concurrent下的并发类：List list = Collections.synchronizedList(new ArrayList(...));CopyOnWriteArrayList list = new CopyOnWriteArrayList();","text":"1. ArrayList概述及层次结构(JDK1.8.0_131): ArrayList的底层是对象数组Object[]，可存储null 未指定初始化大小的默认容量大小是10，超过指定容量后ArrayList采用自动扩容，容量为原来的1.5倍(也就是增加了原来的50%)，1.5倍不大不小刚好，2，2.5。。。都会占用内存大 ArrayList的扩容采用的System.arraycopy()进行复制; 底层是数组决定的查找快，增删慢的特性。get（i），set（i，e） 的性能很高，而remove(i,e)，add(i,e)时需要通过System.arraycopy()复制来达移动数组的目的; ArrayList是非线程安全的，需要同步情况下可在构造时生成同步的List实例或采用java.util.concurrent下的并发类：List list = Collections.synchronizedList(new ArrayList(...));CopyOnWriteArrayList list = new CopyOnWriteArrayList(); 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 2. ArrayList部分源码分析: ArrayList的使用非常多,在下面的分析中会对ArrayList中的set,add,remove等等操作进行源码分析 ArrayList成员变量及作用 123456789101112131415161718//默认数组容量private static final int DEFAULT_CAPACITY = 10;//共享的空数组实例private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//用来表示空ArrayList,当初始add时，用来区分EMPTY_ELEMENTDATA，以便于要扩充多少容量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//ArrayList的底层存储区，如果是空ArrayList构造时//使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素添加时会扩展成 DEFAULT_CAPACITY(10)transient Object[] elementData; //当前ArrayList中(数组中)的存储元素数量private int size;//极限容量，文档注释解释:一些VM在阵列中保留一些标题字。 尝试分配较大的数组可能会导致,OutOfMemoryError：请求的数组大小超过VM限制。private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; ArrayList构造函数 123456789101112131415161718//指定初始容量大小public ArrayList(int initialCapacity);//不指定容量，默认是10，在第一次add()操作时会指定public ArrayList();//将指定的c作为初始内容初始化数组public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) //这个构造函数贴出来主要是说明这个bug(已修复），原因是Object[]对象数组getClass()不一定是 //[Ljava.lang.Object,可以参考http://blog.csdn.net/huzhigenlaohu/article/details/51702737 讲解得很清楚 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; ArrayList的扩容和容量判断方法 自动扩容机制: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//将ArrayList的存储容量缩减实际容量,若实际容量为0，则改成默认大小public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;//如果有必要，增加ArrayList实例的容量，以确保它至少能容纳由最小容量参数指定的元素数量。public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)? 0: DEFAULT_CAPACITY; //上面的操作就是为了判断传入参数与默认容量比较，看是否要扩容 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;//还传入容量与默认容量的比较,取两者中大值private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;//与当前底层数组的容量进行比较，如果比默认容量大，就要扩容了private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;//真正扩容的操作private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //1.5倍的扩容体现在这里 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5扩充后，还要比传入容量小 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //就用传入容量与MAX_ARRAY_SIZE比 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //比MAX_ARRAY_SIZE还要大，再判断 newCapacity = hugeCapacity(minCapacity); //扩容，Arrays中的方法最后会调用System.arraycopy()本地方法进行数组复制 elementData = Arrays.copyOf(elementData, newCapacity);&#125;//最后只能取两个极限Integer.MAX_VALUE或 MAX_ARRAY_SIZE(正常情况肯定不会取到这里来)private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; ArrayList中的add,addAll添加操作 add操作 addAll操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //在数组屁股后面添加元素，必要时会扩容,返回true表示集合中值因这个操作而变化 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; //在指定位置添加元素，插入位置之后的所有元素全部后移，性能差，代价大 public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;//在原数组屁股后添加一个集合的所有元素public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; //从指定index插入一个集合c的所有元素，同样性能差，代价大 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; //这里modCount来自于AbstractList，用来标记并发修改，用 //for-each时迭代会出现ConcurrentModificationException异常.同时需要注意的是 //AbstractList是用来最大限度地减少了实现由“随机访问”数据存储（如数组）支持的接口所需的工作，相应的具体实现只要 //需要或有更好的方式会去实现，不然就是复用 ArrayList中的remove操作 remove操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//remove指定位置操作，返回被remove的值 public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //数组扩容 System.arraycopy(elementData, index+1, elementData, index, numMoved); //清空移动后的位置内容，方便GC elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; //删除指定元素 public boolean remove(Object o) &#123; //如果o为null，删除第一个为null的元素 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //真正的删除操作 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; ArrayList中的查找indexof操作 123456789101112131415161718192021222324252627282930//查找操作，查找第一次出现的位置 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;//删除一定范围内的元素，从fromIndex到toIndexprotected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125;//lastIndexOf()与indexOf()相差不大，反向查找，不贴代码了 3. ArrayList总结: ArrayList底层的数据结构决定的ArrayList的特性，从数据结构来看就看出的哪些操作性能差，哪些操作性能好，应当在不同的场合使用恰当的集合类才是最佳的。除了上面的一些操作，还有一些如ListIterator listIterator()(List特有的迭代，用的少一点); Iterator iterator();等方法没有解析，代码太长，可以直接去参考源码。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://www.yq194.top/tags/Java集合/"}]},{"title":"Java I/O流(一):字节流","slug":"Java-I-O流-一-字节流","date":"2017-11-07T02:04:14.000Z","updated":"2018-01-04T02:35:53.000Z","comments":true,"path":"2017/11/07/Java-I-O流-一-字节流/","link":"","permalink":"http://www.yq194.top/2017/11/07/Java-I-O流-一-字节流/","excerpt":"Java I/O 流(一) : 字节流 Java中流的原理: 可以把Java中IO(从文件、网络等等读写数据都是IO)想像成连接着程序和数据源之间的管道，我们既可以通过管道把数据输出到数据源，也可以通过管道将数据从数据源读入。(管道中流的就是01010101… 这样的字节数据) 将管道中流进行过滤、包装、转换等操作就产生一系列的装饰流。 Java中的IO流是指字节数据（bytes data）从源对象对按顺序流向目标对象的一种流动形式 当说输入流输出流的时候是站在程序的角度来说的。 输入流:程序将数据从数据源(网络、文件等)读入到程序中(实际是内存中) 输出流:程序将数据从程序(内存)中输出(写入)到数据源(网络、文件等)","text":"Java I/O 流(一) : 字节流 Java中流的原理: 可以把Java中IO(从文件、网络等等读写数据都是IO)想像成连接着程序和数据源之间的管道，我们既可以通过管道把数据输出到数据源，也可以通过管道将数据从数据源读入。(管道中流的就是01010101… 这样的字节数据) 将管道中流进行过滤、包装、转换等操作就产生一系列的装饰流。 Java中的IO流是指字节数据（bytes data）从源对象对按顺序流向目标对象的一种流动形式 当说输入流输出流的时候是站在程序的角度来说的。 输入流:程序将数据从数据源(网络、文件等)读入到程序中(实际是内存中) 输出流:程序将数据从程序(内存)中输出(写入)到数据源(网络、文件等) ​(图片来源于网络) Java流的分类: 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 按流向可以分为：输入流和输出流 按处理数据单位大小的不同可以分为：字节流和字符流 按处理功能的不同可以分为：节点流(又叫低级流) 和 处理流(又叫高级流，包装流) ​ 字节流将0101001二进制数据以字节(byte)的方式来读，1个字节(byte)是8位(bit)，读的时候按字节来读； ​ 字符流是以字符为单位读，1个字符是2个字节； ​ 节点流就是直接读数据源里面的数据，或者是直接往数据源里面写入数据,用来读取原始的数据； ​ 处理流是包在别的流上面的流，相当于是包到别的管道上面的管道。 下面是InputStream和OutputStream基本api: 1234567891011121314151617181920212223InputStream(输入流): • 主要方法 abstract int read() //读取一个字节数据， 并返回读到的数据，如果返回-1，表示读到了输入流的末尾。 int read(byte[] b) //将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。 int read(byte[] b, int off, int len)//将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。off 指定在数组b中存放数据的起始偏移位置;len指定读取的最大字节数。 • 其它方法 long skip(long n) //在输入流中跳过n个字节，并返回实际跳过的字节数。 int available() //返回在不发生阻塞的情况下，可读 取的字节数。 void close() //关闭输入流，释放和这个流相关的系统资源。 void mark(int readlimit) //在输入流的当前位置放 置一个标记，如果读取的字节数多于readlimit设置的值， 则流忽略这个标记。 void reset() //返回到上一个标记。 boolean markSupported() //测试当前流是否支持mark和reset方法。如果支持，返回true，否则返回false OutputStream(输出流): • 主要方法 abstract void write(int b) //往输出流中写入一个字节。 void write(byte[] b) //往输出流中写入数组b中的所有字节。 void write(byte[] b, int off,int len) //往输出流中写入数组b中从偏移量off开始的len个字节的数据 • 其它方法 void flush() //刷新输出流，强制缓冲区中的输出字节被写出。 void close() //关闭输出流，释放和这个流相关的系统资源。 InputStream及OutputStream继承体系详解: ​ 在详解之前先放上两张图来整体了解InputStream和OutputStream: ​ InputStream体系结构图(常用类,其中StringBufferInputStream已废弃): ​ ​ OutputStream体系结构图(常用类): ​ ​ 从两张继承体系图可以简单理解： ​ (1) 处理不同的数据来源时，按以下方式来理解比较清晰： ​ 想要处理文件时，来一个子类： FileOutputStream和FileInputStream ​ 想要处理对象时，来一个子类：ObjectInputStream和ObjectOutputStream ​ 想要处理线程间通信时，来一个子类：PipeInputStream和PipedOutputStream ​ 想要处理字节数组时，来一个子类：ByteArrayInputStream和ByteOutputStream ​ 最后，想要多个流进行合并，来一个子类：SequenceInputStream ! 节点流和处理流： 下面是对节点流(包含输入流和输出流)的详细说明 : 1). 节点流 ​ 节点流:从特定的地方读写的流类，例如:磁盘或一块内存区域。 处理类型 字节流 字符流 File(文件) FileInputStream ,FileOutputStream FileReader,FileWriter Mermory Array(内存数组) ByteArrayInputStream, ByteArrayOutputStream CharArrayReader,CharArrayWriter Memory String(内存字符串) ———————————————– StringReader,StringWriter Pipe(管道) PipeInputStream,PipeOutputStream PipeReader,PipeWriter ​ • FileInputStream 和 FileOutputStream ==&gt; 用来处理文件: 123456789101112131415161718192021FileInputStream类创建一个能从文件读取字节的InputStream 类，它的两个常用的方法如下:- FileInputStream(String filepath) throw FileNotFoundException //构造方法- FileInputStream(File fileObj) throw FileNotFoundException //构造方法- FileInputStream(FileDescriptor fdObj) //FileDescriptor为文件描述(封装了不同底层文件系统的统一文件句柄)- int read( ) throws IOException //与InputStream的read一致- FileChannel getChannel() //返回与这个流相关的唯一的FileChannel- FileDescriptor getDF() //返回文件句柄 FileOutputStream类创建一个能从文件读取字节的输出流 类，它的两个常用的方法如下:- FileOutputStream(File file) - FileOutputStream(File file, boolean append)//append指示了在对文件读写时是否追加- FileOutputStream(FileDescriptor fdObj)- FileOutputStream(String name)- FileOutputStream(String name, boolean append)- void write(byte[] b)- void write(byte[] b, int off, int len) //写字节数组，off ~ len- void write(int b)//写指定byte​其它的skip(),available(),close()方法与InputStream中api含意基本相同. ​FileInputStream和FileOutputStream用法: 123456789101112131415161718192021/*** FileInputStream 的示例:* 读取某一文件，并将文件输出生成另一新的文件(或输出每一次读取到的字节并打印)* @throws Exception */public static void test() throws Exception &#123; InputStream is = new FileInputStream(new File(\"/Users/leinl/Desktop/aa.gif\")); //InputStream is = new FileInputStream(\"/Users/leinl/Desktop/aa.gif\"); OutputStream os = new FileOutputStream(\"test.gif\"); byte[] buff = new byte[1024]; int length = 0; int i = 0; while ((length = is.read(buff)) != -1)&#123; //String s = new String(buff,0,length); os.write(buff,0,length); i++; &#125; System.out.println(\"使用buff读了\" + i + \"次\"); os.close(); is.close(); &#125; ​ • ByteArrayInputStream 和 ByteArrayOutputStream ==&gt; 用来处理字节数组: 1234567891011121314151617ByteArrayInputStream是把字节数组当成源的输入流,基内部代码实现是维护了一个用于缓存的buff字节数组:- ByteArrayInputStream(byte[] buf) //构造方法- ByteArrayInputStream(byte[] buf, int offset, int length) //构造方法- int read() //从这个流中读取下一个字节(该类中保存了上一个次读取的位置)- int read(byte[] b, int off, int len) //将数据从这个输入流中读取到一个字节数组中ByteArrayOutputStream调用该输出流的write()方法都会把数据写入到该流中的缓存数组中:- ByteArrayOutputStream() //创建一个新字节数组输出流，默认数组大小32- ByteArrayOutputStream(int size)//创建指定大小的字节数组输出流- int size() //返回当前流中buff的大小- byte[] toByteArray() //产生一个的新的字节数组,Arrays.copy来的- String toString() //产生新的字符串，串\b内容来自于流的byte[]- String toString(String charsetName) //生成指定字符集的新字符串- void write(byte[] b, int off, int len) //将off~len的byte[]写入到这个输出流中- void write(int b) //写指定字节到该流中- void writeTo(OutputStream out) //将out流中的字符写入到该中，相当于调用out.write(buf, 0, count) ​​ByteArrayInputStream和ByteArrayOutputStream用法: 12345678910111213141516171819202122232425262728293031/*** ByteArrayInputStream 和 ByteArrayOutputStream测试*/public static void test() throws Exception&#123; String str = \"Hello ByteArrayInputStream!!!!\"; ByteArrayInputStream is = new ByteArrayInputStream(str.getBytes()); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int ch; while ((ch = is.read()) != -1)&#123; int upperCase = Character.toUpperCase(ch); baos.write(upperCase); &#125; byte[] bytes1 = \"哈哈\".getBytes(); //write(buff,off,len) baos.write(bytes1,0,bytes1.length); //write(buff) baos.write(\"嘿嘿\".getBytes()); byte[] bytes = baos.toByteArray(); System.out.println(baos.toString(\"UTF-8\"));//HELLO BYTEARRAYINPUTSTREAM!!!!哈哈嘿嘿 System.out.println(new String(bytes));//HELLO BYTEARRAYINPUTSTREAM!!!!哈哈嘿嘿 System.out.println(baos.size());//84 //write(outputStream os) baos.writeTo(baos); System.out.println(baos.toString()); is.close(); baos.close(); &#125; ​ • PipeInputStream 和 PipeOutputStream ==&gt; 用来处理线程间的通信 管道流，用于线程间的通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。要使管道流有用，必须同时构造管道输入流和管道输出流。 ​ ​ (图片来自于网络) 从api文档注释来看: 管道输入流应该连接到管道输出流;管道输入流提供了写入管道输出流的数据字节,两个流应分别用两个线程来分别使用使用这两个对象,单个线程操作两个流可能会导致死锁。管道输入流包含缓冲区，提供读写分离。如果为连接的管道输出流提供数据字节的线程已经不再存在，那么就说明该管道被破坏。 1234567891011121314151617181920 &apos;PipedInputStream构造方法:&apos; ​ - PipedInputStream() //创建一个还未连接的PipedInputStream​ ​- PipedInputStream(int pipeSize) //创建一个指定大小缓冲区的PipedInputStream(缓冲区用的是byte[])​ - ​PipedInputStream(PipedOutputStream src) //创建一个PipedInputStream以便于连接传入的输出流src - PipedInputStream(PipedOutputStream src, int pipeSize) //创建指定大小缓冲区的PipedInputStream以便 连接到输出流src​ - int available() ​ - void close() ​ - void connect(PipedOutputStream src) //连接输出流​ - int read() int read(byte[] b, int off, int len)​ &apos;PipedOutputStream构造方法:&apos;​ - PipedOutputStream()​ - PipedOutputStream(PipedInputStream snk) //创建输出流以便连接传入的输入流snk​ - void close()​ - void connect(PipedInputStream snk) //连接输入流​ - void flush()​ - void write(byte[] b, int off, int len)​ - void write(int b) ​ PipeInputStream 和 PipeOutputStream具体使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class PipedInputStreamTest &#123; public static void main(String[] args) &#123; Send send = new Send(); Receive receive = new Receive(); PipedInputStream pi = receive.getPi(); PipedOutputStream pos = send.getPos(); try &#123; //连接 pos.connect(pi); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //开启线程 send.start(); receive.start(); &#125;&#125;class Receive extends Thread&#123; private PipedInputStream pi = new PipedInputStream(); @Override public void run() &#123; try &#123; byte[] buf = new byte[1024]; int len = pi.read(buf); System.out.println(\"接收消息,消息接收者Receive:\" + new String(buf,0,len)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pi.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public PipedInputStream getPi() &#123; return pi; &#125;&#125;class Send extends Thread&#123; PipedOutputStream pos = new PipedOutputStream(); @Override public void run() &#123; try &#123; String str = \"hello the world\"; pos.write(str.getBytes()); System.out.println(\"发送消息,消息来源于Send:\" + str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public PipedOutputStream getPos() &#123; return pos; &#125;&#125; ​ 以上就是几个常见的节点流的详细介绍，下面是处理流介绍: 2). 处理流 ​ . 处理流:”连接”在已存在的流(节点流或处理流)上，通过对数据的处理为程序提供更强大的功能的流类。 处理类型 字节流 字符流 Buffering BufferedInputStream ,BufferedOutputStream BufferedReader,BufferedWriter Filtering FilterInputStream,FilterOutputStream FilterReader,FilterWriter Converting between Bytes And Character ———————————————– InputStreamReader,OutputStreamWriter Object Serialization ObjectInputStream,ObjectOutputStream —————————————— Data Conversion DataInputStream,DataOutputStream —————————————— Counting LineNumberInputStream LineNumberReader Peaking PushbackInputStream PushbackReader Printing PrintStream PrintWriter a). 第一种处理流：对象流• ObjectInputStream 和 ObjectOutputStream ==&gt; 用来处理被序列化的对象 12345-ObjectInputStream(InputStream in) //构造方法​一系列的read方法如:readInt(),readBoolean()…用从in流中的读取各种对象。​-ObjectOutputStream(OutputStream out) //构造方法 ​ 其他公有方法可与ObjectInputStream类比。具体使用见如下代码: 12345678910111213141516171819202122232425262728293031323334public static void test() throws Exception&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"output.txt\"))); byte[] str = \" the world!\".getBytes(); //void write(byte[] buf) oos.write(str); //void write(byte[] buf,int off,int len) oos.write(str,0,str.length); //void write(double val) oos.writeDouble(2.0D); //void write(int val) oos.write(20); oos.writeByte(112); oos.writeChar('C'); oos.writeBoolean(false); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"output.txt\"))); byte[] readBytes = new byte[str.length]; ois.read(readBytes); System.out.println(new String(readBytes)); ois.read(readBytes); System.out.println(new String(readBytes)); double v = ois.readDouble(); System.out.println(v); byte i = ois.readByte(); System.out.println(i); byte b = ois.readByte(); System.out.println(b); char c = ois.readChar(); System.out.println(c); boolean b1 = ois.readBoolean(); System.out.println(b1); ois.close(); &#125; b). 第二种处理流：缓冲流​ • SequenceInputStream ==&gt; 用来处理多个流(数据源)的连接 缓冲输入/输出是一个非常普通的性能优化。Java 的BufferedInputStream类允许把任何InputStream 类“包装”成缓冲流,对数据读取提供了缓冲的功能并使它的性能提高 123456​ - public SequenceInputStream(InputStream s1,InputStream s2) //构造方法，提供一个SequenceInputStream，其提供字节读入的来源是s1,s2,初始化时按先s1再s2的顺序。 - public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) //构造方法，按顺序读取Enum中的流集合从而初始化一个SequenceInputStream​两个主要的read方法: - int read() //读下一个字节​ - int read(byte[] b, int off, int len)//读指定buf的off-len长度的byte[] 1234567891011121314public static void test() throws Exception&#123; Vector&lt;InputStream&gt; vector = new Vector&lt;&gt;(2); vector.add(new FileInputStream(new File(\"output.txt\"))); vector.add(new ByteArrayInputStream(\"hello\".getBytes())); Enumeration&lt;InputStream&gt; elements = vector.elements(); SequenceInputStream sis = new SequenceInputStream(elements); byte[] buff = new byte[1024]; int len; FileOutputStream fos = new FileOutputStream(new File(\"output2.txt\")); while ((len = sis.read(buff)) != -1)&#123; fos.write(buff,0,len); &#125; fos.close(); &#125; ​","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://www.yq194.top/tags/IO/"}]},{"title":"mysql join 详解","slug":"Mysql join types","date":"2017-05-13T14:44:21.000Z","updated":"2018-01-04T02:36:35.000Z","comments":true,"path":"2017/05/13/Mysql join types/","link":"","permalink":"http://www.yq194.top/2017/05/13/Mysql join types/","excerpt":"SQL JOIN是从两个或多个数据库表中检索数据的方法。本文介绍了特定SQL联接中的数据的基本概述。理解SQL连接的流行方式是使用维恩图进行可视化，因此每个示例都有相应的维恩图，适当的SELECT语句和结果表。本文参考链接: ​ https://dev.mysql.com/doc/refman/5.6/en/join.html mysql官方文档 ​ https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins codeproject文章 ​ https://academy.vertabelo.com/blog/sql-joins/ mysql joins ​ http://stevestedman.com/2015/03/mysql-join-types-poster/ 某博客整理的join图 ​ http://stackoverflow.com/questions/5706437/whats-the-difference-between-inner-join-left-join-right-join-and-full-join/6188334#6188334 stackoverflow","text":"SQL JOIN是从两个或多个数据库表中检索数据的方法。本文介绍了特定SQL联接中的数据的基本概述。理解SQL连接的流行方式是使用维恩图进行可视化，因此每个示例都有相应的维恩图，适当的SELECT语句和结果表。本文参考链接: ​ https://dev.mysql.com/doc/refman/5.6/en/join.html mysql官方文档 ​ https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins codeproject文章 ​ https://academy.vertabelo.com/blog/sql-joins/ mysql joins ​ http://stevestedman.com/2015/03/mysql-join-types-poster/ 某博客整理的join图 ​ http://stackoverflow.com/questions/5706437/whats-the-difference-between-inner-join-left-join-right-join-and-full-join/6188334#6188334 stackoverflow 一、一般来说，大致分为如下四类: INNER JOIN (内连接) OUTER [LEFT | RIGHT | FULL] JOIN （外连接） NATURAL JOIN (自然连接) CROSS JOIN （交叉连接） (mysq中有TRAIGHT_JOIN) 值得注意的是内连接和外连接后接的条件操作符可以是”&gt;”,”&lt;”,”=”,”&gt;=”,”&lt;=” 但是,mysql官方文档中是这样写的: ​ MySQL对SELECT语句的table_references(下面的引用)部分和多表DELETE和UPDATE语句支持JOIN语法(具体如下 )： 1234567891011121314151617181920212223242526272829303132333435363738394041table_references: escaped_table_reference [, escaped_table_reference] ...escaped_table_reference: table_reference | &#123; OJ table_reference &#125;table_reference: table_factor | join_tabletable_factor: tbl_name [PARTITION (partition_names)] [[AS] alias] [index_hint_list] | table_subquery [AS] alias | ( table_references )join_table: table_reference [INNER | CROSS] JOIN table_factor [join_condition] | table_reference STRAIGHT_JOIN table_factor | table_reference STRAIGHT_JOIN table_factor ON conditional_expr | table_reference &#123;LEFT|RIGHT&#125; [OUTER] JOIN table_reference join_condition | table_reference NATURAL [&#123;LEFT|RIGHT&#125; [OUTER]] JOIN table_factorjoin_condition: ON conditional_expr | USING (column_list)index_hint_list: index_hint [, index_hint] ...index_hint: USE &#123;INDEX|KEY&#125; [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list]) | IGNORE &#123;INDEX|KEY&#125; [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list) | FORCE &#123;INDEX|KEY&#125; [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)index_list: index_name [, index_name] ... 从上来看，主要两个方面: ​ 1.mysql中会有以下join出现: ​ INNER JOIN( 内连接),CROSS JOIN(交叉连接),这两个可以不带ON ​ STRAIGHT_JOIN(直接连接,可带ON也可以不带ON), ​ LEFT|RIGHT|FULL [OUTER] JOIN 左连接或左外连接或全连接, ​ NATURAL [{LEFT|RIGHT} [OUTER]] JOIN 自然连接(左|右) ​ 2.mysql中可以使用USING来处理像ON这样的条件，下面会详细说明。 二、用实例来说明这些JOIN的区别:​ 首先定两张表如下: 12345678 TableB TableA+------+--------+ +------+--------+| b_id | b_name | | a_id | a_name |+------+--------+ +------+--------+| A | apple | | 1 | apple || B | banana | | 2 | orange || C | NULL | | 3 | NULL |+------+--------+ +------+--------+ ​ （一）外连接(左外连接，右外连接，完整外连接) LEFT JOIN: 12345678select * from TableA left join TableB on TableA.a_name = TableB.b_name+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || 2 | orange | NULL | NULL || 3 | NULL | NULL | NULL |+------+--------+------+--------+ left join 以左表主基准,返回左表的全部记录，如果on后面条件匹配，会带出右表的匹配记录,右表中不匹配的列全是NULL。下面为图解: ​ (不难看出:连接出来不等的右边会取一条null记录来给左表对应) {0}. RIGHT JOIN 12345678SELECT * FROM test.TableA RIGHT JOIN test.TableB ON test.TableA.a_name = test.TableB.b_name;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || NULL | NULL | B | banana || NULL | NULL | C | NULL |+------+--------+------+--------+ 与LEFT JOIN相反 : ![2.pic](/images/2.pic.jpg) {0}. FULL JOIN（不能带ON条件） 1234567891011121314select * from TableA full join TableB;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || 1 | apple | B | banana || 1 | apple | C | NULL || 2 | orange | A | apple || 2 | orange | B | banana || 2 | orange | C | NULL || 3 | NULL | A | apple || 3 | NULL | B | banana || 3 | NULL | C | NULL |+------+--------+------+--------+ 外连接的full join 及自然连接的natural join不能带on条件，cross join可以带on条件 如果三者都不带条件的情况下就全连接即笛卡尔集！ ​ #### （二）内连接(INNER JOIN) {0}. INNER JOIN 123456select * from TableA inner join TableB on TableA.a_name = TableB.b_name+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple |+------+--------+------+--------+ inner join会根据条件匹配找到条件相等的列，它并不像上面的left join 和right join一样返回左或右边表的所有记录。 （三）交叉连接(CROSS JOIN) 5.CROSS JOIN（通常的笛卡尔集） 1234567891011121314select * from TableA cross join TableB;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || 1 | apple | B | banana || 1 | apple | C | NULL || 2 | orange | A | apple || 2 | orange | B | banana || 2 | orange | C | NULL || 3 | NULL | A | apple || 3 | NULL | B | banana || 3 | NULL | C | NULL |+------+--------+------+--------+ 就是依次把左表的每一列去与右所有列对应，相当于A:2x3, B:2x3 == &gt; 4*9 ; cross join不带条件就笛卡尔集，带条件就会根据条件去掉相应的列!!! （四）自然连接(NATURAL JOIN),应该可以直接分类到外连接包括为左自然连接和右自然连接(需要注意：自然连接不带ON条件) NATURAL JOIN 这个就不用列出了，就是笛卡尔集，也是full join NATRUAL LEFT JOIN|NATRUAL LEFT JOIN natural join分左右应该只是连接时以左或右为基准去连接，实际上连接 的结果与natural join的结果一样。（感觉这个自然连接意义不大） ​ 二、下面再来讨论一些比较特殊但可能很有用的JOINS LEFT JOIN EXCLUDING INNER JOIN 12345678SELECT * FROM TableA LEFT JOIN test.TableB ON TableA.a_name = TableB.b_nameWHERE TableB.b_name IS NULL;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 2 | orange | NULL | NULL || 3 | NULL | NULL | NULL |+------+--------+------+--------+ 返回的结果中是左表的结果(不包含两表的交集‘) Right Excluding JOIN1234567mysql&gt; SELECT * FROM TableA RIGHT JOIN TableB ON TableA.a_name = TableB.b_name WHERE TableA.a_name IS NULL;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| NULL | NULL | B | banana || NULL | NULL | C | NULL |+------+--------+------+--------+ 返回的结果是右表的集(除去了两表的交集) Outer Excluding JOIN123SELECT * FROM TableA JOIN test.TableB ON TableA.a_name = TableB.b_name WHERE TableA.a_name IS NULL OR TableB.b_name IS NULL;等价于: (Right Excluding JOIN) UNION (LEFT JOIN EXCLUDING INNER JOIN) ​ 返回的是两表的非交集,这里没有数据主要是我表的数据设置有点问题，不过从 https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins 这篇文章及例子可以了解。 最后mysql中有一个STRAIGHT_JOIN,它的表现与INNER JOIN相同，详细请看下面这个博客 : ​ 【MySQL】性能优化之 straight_join 三、总结 :​ 通过以上的分类可以了解到sql join的具体分类及使用,通过整理应该可以更加好的了解sql join以及mysql join的具体形式及用法 .下面放上盗来的图）)： ​ 图1： ​ 图2：下图还包含3表连接的状态 : 注:图中部分出处都有地址注明，请参见文章开头","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.yq194.top/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.yq194.top/tags/MySQL/"}]}]}