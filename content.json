{"meta":{"title":"Notes","subtitle":"","description":"好记性不如烂笔头。","author":"Yang","url":"http://www.yq194.top"},"pages":[{"title":"","date":"2018-01-02T09:14:21.000Z","updated":"2017-01-24T06:50:16.000Z","comments":true,"path":"404.html","permalink":"http://www.yq194.top/404.html","excerpt":"","text":"404"},{"title":"分类","date":"2018-01-03T08:39:27.000Z","updated":"2018-01-03T08:39:27.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.yq194.top/categories/index.html","excerpt":"","text":""},{"title":"常用标签","date":"2018-01-03T08:40:36.000Z","updated":"2018-01-03T08:40:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.yq194.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-24T07:28:01.000Z","updated":"2017-04-08T05:58:28.000Z","comments":true,"path":"about/index.html","permalink":"http://www.yq194.top/about/index.html","excerpt":"","text":"据我们所知，我们已经知道一些，我们知道我们已经知道一些，我们还知道，我们有些并不知道，也就是说，我们知道有些事情我们还不知道，但是，还有一些，我们并不知道我们不知道，这些我们不知道的，我们不知道 Mr’ Yang"}],"posts":[{"title":"JVM GC 笔记","slug":"JVM-GC-笔记","date":"2018-01-31T08:19:12.000Z","updated":"2018-01-31T09:05:12.000Z","comments":true,"path":"2018/01/31/JVM-GC-笔记/","link":"","permalink":"http://www.yq194.top/2018/01/31/JVM-GC-笔记/","excerpt":"","text":"JVM GC笔记 链接地址: https://github.com/IlilIliI/practice-in-java/tree/master/practice-javase-basic/src/main/java/com/github/IlilIliI/jvm/doc","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.yq194.top/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yq194.top/tags/JVM/"}]},{"title":"Java集合系列(五):PriorityQueue优先队列","slug":"Java集合系列-五-PriorityQueue优先队列","date":"2018-01-07T12:56:06.000Z","updated":"2018-01-09T07:23:25.000Z","comments":true,"path":"2018/01/07/Java集合系列-五-PriorityQueue优先队列/","link":"","permalink":"http://www.yq194.top/2018/01/07/Java集合系列-五-PriorityQueue优先队列/","excerpt":"1. PriorityQueue概述: PriorityQueue类实现了Queue接口，她的作用是：能保证每次取出的元素都是队列中权值最小的元素。 遵守了Queue接口的约定：不能存储null值。 PriorityQueue类非线程同步，需要线程同步可使用PriorityBlockingQueue类。 底层实现是数组,以数组的形式维护了一个二叉堆，通过该堆来维护权重。 2. 关于PriorityQueue下的二叉堆: 二叉堆有如下特性： 任意一个节点的值总是不大于（最大堆）或者不小于（最小堆）其父节点的值 堆是一棵完全二叉树 而利用数组来存储这个堆，父节点与左右孩子节点的数组下标会有如下规律： leftNode = 2 * parentNode + 1 rightNode = 2 * parentNode + 2 parentNode = (index - 1) / 2","text":"1. PriorityQueue概述: PriorityQueue类实现了Queue接口，她的作用是：能保证每次取出的元素都是队列中权值最小的元素。 遵守了Queue接口的约定：不能存储null值。 PriorityQueue类非线程同步，需要线程同步可使用PriorityBlockingQueue类。 底层实现是数组,以数组的形式维护了一个二叉堆，通过该堆来维护权重。 2. 关于PriorityQueue下的二叉堆: 二叉堆有如下特性： 任意一个节点的值总是不大于（最大堆）或者不小于（最小堆）其父节点的值 堆是一棵完全二叉树 而利用数组来存储这个堆，父节点与左右孩子节点的数组下标会有如下规律： leftNode = 2 * parentNode + 1 rightNode = 2 * parentNode + 2 parentNode = (index - 1) / 2 leftNode表示左孩子的数组下标,rightNode表示右孩子的下标,parentNode表示父节点的数组下标,index表示任意某一非空节点的数组下标。下面是一个堆的示意图: 对比上图和对应的下标规律就可以很清晰的看出父节点与子节点之间的关系。那么堆的创建过程是怎么样的呢？实际上，每添加一个元素，就会进行权重的比较，从而将元素置为符合二叉堆特性的合适的位置,下图表示的是一个堆的创建过程： 在PriorityQueue中，通过Comparable接口来实现元素之间的比较，从而得到元素的优先级。如果没有指定Comparable接口,那PriorityQueue将会按照默认规则比较，且实现的堆为最小堆。 3. PriorityQueue源码解析(JDK1.8.0_131): 首先PriorityQueue底层为Object[] queue,有如下7个构造方法: 123456789101112131415//空构造，默认数组大小11public PriorityQueue();//指定初始大小public PriorityQueue(int initialCapacity);//指定比较器，但不指定初始大小public PriorityQueue(Comparator&lt;? super E&gt; comparator);//指定比较器和初始大小public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) ;//指定集合内容来构造public PriorityQueue(Collection&lt;? extends E&gt; c);//指定某一个PriorityQueue的内容来构造 public PriorityQueue(PriorityQueue&lt;? extends E&gt; c);//指定SortedSet的内容来构造public PriorityQueue(SortedSet&lt;? extends E&gt; c); 如果传入的是PriorityQueue或SortedSet实例，需要对类型和容量大小进行判断，进行相应的扩容或类型处理。 PriorityQueue的创建 如果是初始化指定是某集合如Collection&lt;? extends E&gt; c,那PriorityQueue创建时会从插入最后一个元素的父节点位置开始建堆；否则，就会按照offer()方法来边添加元素边调堆结构创建堆。下面是指定集合时创建堆所调用的方法： 123456private void heapify() &#123; //最后一个元素的父节点,siftDown方法见poll()方法解析 for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) //每一个父节点一层一层往下与左右孩子节点比较 siftDown(i, (E) queue[i]);&#125; add()和offer()方法 add()和offer()方法区别在于返回值和抛出异常的不同，这里其实是一样的，重点关注插入元素的操作。以下面add(10)这个操作为例(这里是最大堆,最小堆最大堆原理一样): 源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; //size是queue的元素个数 int i = size; if (i &gt;= queue.length) //创建一个更大的数组把原queue复制过去 grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else //下一个数组位置加入元素 siftUp(i, e); return true;&#125;//根据有没comparator分开处理 private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125;//添加新元素并保证原有堆的结构不被破坏private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; //k = 0 停止，也就是parent = 0(最小/最大推顶)处停止 while (k &gt; 0) &#123; //往上找父节点:parentNode = (index - 1) / 2 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; //如果比较大(小)，不满足交换,直接跳出循环,表示已找到该元素的合适位置 if (key.compareTo((E) e) &gt;= 0) break; //与父节点交换元素 queue[k] = e; //k变成parent的下标，不为0就继续循环while k = parent; &#125; queue[k] = key;&#125; offer操作实际上把当前要加入的元素在加入的同时保证堆结构的原有特性，从k开始，与每层的父节点进行比较直到key.compareTo((E) e)条件满足,不满足时比较到 k = 0处(parent处)停止。siftUp()表示要么是按自然顺序比较，要么是按比较器比较。 element()和peek()方法 element和peek都表示返回堆中权重最大(最小)的元素，且不删除该元素。前者失败时抛出异常，后者失败时返回null,其他方面无区别。不删除元素，意味着只找元素返回，比较简单。如下: 源码: 12345//parent = 0 即可@SuppressWarnings(&quot;unchecked&quot;)public E peek() &#123; return (size == 0) ? null : (E) queue[0];&#125; remove()和poll()方法 与前面的一样poll操作删除元素并返回元素值,失败时与remove仅是返回值与抛出异常的不同。这里主要关注删除元素后，堆的结构变化如何保证： 源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; //返回为0下标的元素 E result = (E) queue[0]; E x = (E) queue[s]; //删除最后一个元素,用最后一个元素与s = 0位置的元素互换，因为最后一个一般是极大(或小)值 queue[s] = null; if (s != 0) //如果不是堆中最后一个元素，就要调整堆结构 siftDown(0, x); return result;&#125;//根据比较不同来调用，具体实现基本一致private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125;//调整堆结构private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; //取一半大小比较,因为没有跟叶子节点比较的机会 int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; //k的左孩子 : leftNode = 2 * parentNode + 1，这里假设右边是要交换的 int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; //k的右孩子 int right = child + 1; //取左右孩子节点中大(或小)的节点 if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) //交换right为k c = queue[child = right]; //找到了比x大(或小)的元素，跳出循环 if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; //k继续向下左右孩子节点找应该交换的直到k = half停止 k = child; &#125; queue[k] = key;&#125; 先将删除元素x与第0个元素互换，再拿这个元素调用siftDown(0,x)。siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的(较大)那个交换，直到x小于(大于)或等于左右孩子中的任何一个为止。。而上图中当4节点与8节点交换后，8节点跟7节点交换而不跟6节点交换的原因就在这里(这里是最大堆)。 * Collection接口下的remove(Object o) 该方法是Collection接口中的，不算Queue接口方法，只是继承下来了。当执行该方法时可能会使用堆结构发生改变，所以要调用siftDown()方法调整堆结构，仍然是一层一层往下与左右孩子节点比，找到合适的位置。如果remove的是最后一个元素，则直接干掉；如果不是最后一个，就要调整堆。 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public boolean remove(Object o) &#123; int i = indexOf(o); if (i == -1) return false; else &#123; removeAt(i); return true; &#125;&#125; private E removeAt(int i) &#123; // assert i &gt;= 0 &amp;&amp; i &lt; size; modCount++; int s = --size; //是最后一个元素 if (s == i) // removed last element queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; //与最后一个元素交换,并一层一层向下与左右孩子节点比较 siftDown(i, moved); //如果执行siftDown方法向下比较后位置没变，说明该元素是该子树的最小(最大)元素，需要执行上调方 if (queue[i] == moved) &#123; //现原来被删除的位置相同，就往上与父节点比较 siftUp(i, moved); if (queue[i] != moved) return moved; &#125; &#125; return null;&#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125;private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; //找父节点：parentNode = (index - 1) / 2 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key;&#125; 只需要往下比较就能调整好位置: 往下比较好，发现回到原来位置，此时需要往上与父节点比较: 4. 总结: 时间复杂度：offer(),poll(), remove() and add()方法时间复杂度为O(logn);remove(Object obj)和contains()方法需要O(n)时间复杂度;peek()、element()和size()常数时间; 存储堆的数组是无序的，有序输出需要Arrays.sort() 不能存储null元素且线程不安全 参考链接: http://blog.csdn.net/u011116672/article/details/50997622 https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md 3Q and End!!!!!!!!!!!","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://www.yq194.top/tags/Java集合/"}]},{"title":"Java集合系列(四):Queue,Stack和Deque","slug":"Java集合系列-四-Queue-Stack和Deque","date":"2018-01-06T17:14:51.000Z","updated":"2018-01-07T13:00:56.000Z","comments":true,"path":"2018/01/07/Java集合系列-四-Queue-Stack和Deque/","link":"","permalink":"http://www.yq194.top/2018/01/07/Java集合系列-四-Queue-Stack和Deque/","excerpt":"对比Queue(接口),Stack(类)和Queue(接口)之间的实现，将有利于更好的了解其实现体系及原理。 1. Queue,Stack和Deque之间的区别: 通过LinkedList的类结构层次和源码可以了解到LinkedList既可以当作Queue又可以当作Deque（”double ended queue”的简称,发音”Deck”），而在JDK集合类中还有一个Stack类表示栈（父类是Vector），但推荐使用的ArrayDeque（Deque的子类）这个以数组为底层实现的双端队列来表示栈。 2. JDK中Queue接口与Deque接口的各自主要方法:","text":"对比Queue(接口),Stack(类)和Queue(接口)之间的实现，将有利于更好的了解其实现体系及原理。 1. Queue,Stack和Deque之间的区别: 通过LinkedList的类结构层次和源码可以了解到LinkedList既可以当作Queue又可以当作Deque（”double ended queue”的简称,发音”Deck”），而在JDK集合类中还有一个Stack类表示栈（父类是Vector），但推荐使用的ArrayDeque（Deque的子类）这个以数组为底层实现的双端队列来表示栈。 2. JDK中Queue接口与Deque接口的各自主要方法: Queue的主要方法概要 抛出异常 返回指定值 Insert add(e) offer(e) Remove remove() poll() Examine element() peek() 其中，无论作为队列FIFO还是堆栈LIFO，都是通过调用remove()或poll()来移除的元素，返回被移除的元素。offer()通过返回null/false来表示插入元素成功与否，add()通过检查异常来判断；element()和peek()也同样如此，不过他们表示的是只取头元素，而不删除。Queue通常应当不存储null元素(LinkedList可以存储null)。 Deque双端队列的主要方法概要 头元素(head) 尾元素(tail) 抛出异常 返回指定值 抛出异常 返回指定值 Insert addFirst() offerFirst() addLast() offerLast() Remove removeFirst() poolFirst() removeLast() poolLast() Examine getFirst() peekFirst() getList() peekLast() 因为Deque是双端队列，一个引用head指向头,一个引用tail指向尾，所以两端都可以添加，移除和获得元素。同样地，当进行操作时也有以抛出异常 和返回true/false来标识操作成功与否。Deque的子类应当不存储null元素。 Stack栈(是类而不是接口)的主要方法概要 push(e) pop() peek() Stack类的主要是三个方法push(e)元素入栈，pop()元素出栈并删除栈顶元素,peek()元素出栈但不删除栈顶元素。同时，Stack继承自Vector类，是线程同步类(但全是方法上加synchronized来同步，性能不是很好),其继承体系如下: 123public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; ...&#125; 可以存储null元素,已不推荐使用该类作为栈使用,推荐使用Deque的子类实现: 1Deque&lt;E&gt; deque = new ArrayDeque&lt;&gt;(); 3. JDK中Queue接口，Deque接口与Stack类的方法对比: Deque与Queue相对应的接口： Queue Method Equivalent Deque Method 对应操作的说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove() removeFirst() 获取并删除队首元素，失败则抛出异常 poll() pollFirst() 获取并删除队首元素，失败则返回null element() getFirst() 获取但不删除队首元素，失败则抛出异常 peek() peekFirst() 获取但不删除队首元素，失败则返回null Deque与Stack对应的接口： Stack Method Equivalent Deque Method 对应操作的说明 push(e) addFirst(e) 向栈顶插入元素，失败则抛出异常 无 offerFirst(e) 向栈顶插入元素，失败则返回false pop() removeFirst() 获取并删除栈顶元素，失败则抛出异常 无 pollFirst() 获取并删除栈顶元素，失败则返回null peek() peekFirst() 获取但不删除栈顶元素，失败则抛出异常 无 peekFirst() 获取但不删除栈顶元素，失败则返回null Deque接口中的方法主要是添加/删除/查看三类操作，与Queue接口和Stack类在这三个操作方面进行类比就能很好的分清这些方法。总之，很好区分的是Deque接口既能当队列又能当栈，Stack类就是JDK实现的栈，Queue接口就队列接口高层抽象。前面有解析Queue的实现LinkedList类，接下来就是Deque的实现ArrayDeque。 4. ArrayDeque类的源码解析(JDK1.8.0_131): ArrayDeque底层实现是数组transient Object[] elements;有head指向头部第一元素的位置，tail指向尾部第一个可插入元素的位置，而且底层数组利用System.arraycopy()来进行扩容。所以综合来说，ArrayDeque底层实现应该是循环数组。 123456//底层存储的数组transient Object[] elements; //指向首端位置，head可能为负transient int head;//指向尾端位置，tail不一定总比head大transient int tail; 如上图，随着不断的对数组进行操作，head和tail的位置不断的在发生变化。下面来看一些基本操作的方法: addFirst(e)往首部添加元素 如上添加 10 这个元素，addFirst(e)往首部添加是head在移动，具体源码如下: 12345678910public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); //给数组填充值,这里如果head为负的话，通过 //(head - 1) &amp; (elements.length - 1)操作能取成正值 elements[head = (head - 1) &amp; (elements.length - 1)] = e; //进行容量大小判断 if (head == tail) doubleCapacity();&#125; 这里需要注意(1).数组容量大小 (2).数组head或tail(addLast)取非负值的问题。添加元素如addFisrt,addLast都是先赋值再进行head==tail的判断,因为tail永远指向下一个可添加元素的位置。其实主要原因还是在elements.length - 1这个位置做了手脚，看下面的源码: 12345678910111213141516171819202122232425 //空构造函数默认数组大小16，而非空构造会调用如下方法 private void allocateElements(int numElements) &#123; // MIN_INITIAL_CAPACITY 为 8 int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full. //如果传入numElements &lt; 8,那构造数组大小为8 if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; //下面的操作会把initialCapacity变成接近于 //numElements附近的值(2的K次方) //比如 numElements = 9或10或14， //initialCapacity都会变成16,依此类推 initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; elements = new Object[initialCapacity];&#125; 由于上面的无符号位移和异或操作会把initialCapacity变成2的k次方,相应的elements.length - 1的二进制永远是1111111...,再进行类似于addFirst(e)中的(head - 1) &amp; (elements.length - 1)操作，&amp;(与操作，1&amp;1时才为1)操作前缀不管是不是负值都会变成非负值，从而保证了head移动到取负值时也能把head变成相应的非负值,同时&amp;操作也保证了不越出elements.length这个界限。 addLast(e)往尾部添加元素 123456789 public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); //先赋值 elements[tail] = e; //检查tail越界情况，addLast移动的是tail if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity();&#125; 这里需要看一下doubleCapacity()这个扩容操作: 123456789101112131415161718192021private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; // head右边元素个数 int r = n - p; // number of elements to the right of p //原数组长度的2位 int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(&quot;Sorry, deque too big&quot;); Object[] a = new Object[newCapacity]; //先复制head右边（图绿色部分） System.arraycopy(elements, p, a, 0, r); //再左边部分(图黄色部分) System.arraycopy(elements, 0, a, r, p); //数组替换 elements = a; //head，tail重新初始位置 head = 0; tail = n; &#125; 扩容操作就是容量扩充一倍，然后把head和tail相等位置的部分分别先head往右再tail往左复制过来，并初始化head=0,tail=length-1即可。 *peekFirst() peekFirst()的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。 123public E peekFirst() &#123; return elements[head]; // elements[head] is null if deque empty&#125; pollFirst() pollFirst用于删除首部元素，并将该元素返回。 123456789101112public E pollFirst() &#123; int h = head; @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot //重新定位head head = (h + 1) &amp; (elements.length - 1); return result; &#125; peekLast() peekLast()的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。 123public E peekLast() &#123; return elements[(tail - 1) &amp; (elements.length - 1)];&#125; pollLast() pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。 123456789public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result;&#125; 其他一系列操作基本上是基于以上操作，就不细说了。 本文参考链接: https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md http://calvin1978.blogcn.com/articles/collection.html 3Q AND END!!!","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://www.yq194.top/tags/Java集合/"}]},{"title":"Java集合系列(三): LinkedList源码笔记","slug":"Java集合系列(三): LinkedList源码笔记","date":"2018-01-02T07:03:18.000Z","updated":"2018-01-06T17:32:07.000Z","comments":true,"path":"2018/01/02/Java集合系列(三): LinkedList源码笔记/","link":"","permalink":"http://www.yq194.top/2018/01/02/Java集合系列(三): LinkedList源码笔记/","excerpt":"1. LinkedList概述及层次结构(JDK1.8.0_131): LinkedList的继承体系中有List接口，Queue接口和Deque接口(double ended queue),表示明了LinkedList既能当作链表又能当作队列(Queue)还能当作栈(Stack);FIFO,LIFO及顺序访问都可以满足，虽然JDK中有Stack(继承自Vector),但官方推荐使用ArrayDeque. LinkedList底层采用双向链表(prev头节点，next尾节点)，元素可以为null,空链表时prev=next=null. LinkedList线程不安全,可以使用Collections.synchronizedList(List list)进行包装. LinkedList插入，删除操作常数时间，顺序访问线性时间.","text":"1. LinkedList概述及层次结构(JDK1.8.0_131): LinkedList的继承体系中有List接口，Queue接口和Deque接口(double ended queue),表示明了LinkedList既能当作链表又能当作队列(Queue)还能当作栈(Stack);FIFO,LIFO及顺序访问都可以满足，虽然JDK中有Stack(继承自Vector),但官方推荐使用ArrayDeque. LinkedList底层采用双向链表(prev头节点，next尾节点)，元素可以为null,空链表时prev=next=null. LinkedList线程不安全,可以使用Collections.synchronizedList(List list)进行包装. LinkedList插入，删除操作常数时间，顺序访问线性时间. 1234// 来自于源码JDK1.8.0_131public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 2. LinkedList源码解析(JDK1.8.0_131): 只列出一些比较常用的操作和部分方法解析 2.1 属性及定义: 12345678910111213141516171819202122232425262728293031323334//链表长度(节点数量)transient int size = 0;//头节点transient Node&lt;E&gt; first;//尾节点transient Node&lt;E&gt; last;//内部节点类private static class Node&lt;E&gt; &#123; //节点元素 E item; //指定上一节点 Node&lt;E&gt; next; //指向下一节点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;//构造方法:空链表 public LinkedList() &#123;&#125;//构造方法:以集合作为初始链表public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 2.1 几个基本操作所用到的方法源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** 往链表屁股后添加元素*/void linkLast(E e) &#123; //用临时变量l指向尾节点 final Node&lt;E&gt; l = last; //以l作为头节点，e为元素创建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //将尾节点指向新节点 last = newNode; //如果是空链表，first=next=新节点 if (l == null) first = newNode; else //否则把原来尾节点的next指向新节点，以确保双链不断 l.next = newNode; //链表长度增加 size++; //修改标记变量增加 modCount++;&#125;/* * 在链表头插入一个元素为e的节点 */ private void linkFirst(E e) &#123; //临时变量f指向头节点 final Node&lt;E&gt; f = first; //以元素e为尾节点创建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //头节点指向新节点 first = newNode; //如果是空链，头尾都指向新节点 if (f == null) last = newNode; else //否则原来的头节点的前一节点指向新节点，保证双链不断 f.prev = newNode; size++; modCount++;&#125;//在非null节点succ前插入元素为e的新节点void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null;succ的前驱节点 final Node&lt;E&gt; pred = succ.prev; //构造新节点，前驱pred,后继succ final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //设置succ的前驱 succ.prev = newNode; //如果前驱pred为空，表示原来succ=first if (pred == null) //现在first = newNode first = newNode; else //否则设置前驱pred的后继节点 pred.next = newNode; size++; modCount++;&#125;/** * 解除非空头节点f，返回f的值 */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null;返回元素 final E element = f.item; //后继节点 final Node&lt;E&gt; next = f.next; //item引用指向null,帮助GC f.item = null; //f节点的next引用指向null,帮助GC f.next = null; // help GC //链表头节点指向f的后继节点 first = next; //如果后继节点为空，链表尾节点设置为null if (next == null) last = null; else //否则把后继节点的前驱与f断开(未删除时本来指向f） next.prev = null; size--; modCount++; return element;&#125;/** * 解除链表的非空尾节点l,返回节点l的值 */private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null;尾节点元素值 final E element = l.item; //拿到l的前驱prev final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC //把链表尾节点指向prev last = prev; //如果prev为null表示删除l后链表空了 if (prev == null) //first指向null first = null; else //否则把prev的后继置为空 prev.next = null; size--; modCount++; return element;&#125;/** * 解除非空节点x，返回x节点的值 */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; //后继 final Node&lt;E&gt; next = x.next; //前驱 final Node&lt;E&gt; prev = x.prev; //x的前驱为空，链表头节点first指向x的后继 if (prev == null) &#123; first = next; &#125; else &#123; //否则前驱的后继指向x的后继next prev.next = next; x.prev = null; &#125; //x的后继为空，链表的尾节点last指向prev if (next == null) &#123; last = prev; &#125; else &#123; //否则x的后继的前驱指向prev next.prev = prev; //x的后继指向空,help gc x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; (1).addFirst()操作 1234public void addFirst(E e) &#123; //见上面的linkFirst源码 linkFirst(e);&#125; (2).addLast()操作 1234public void addLast(E e) &#123; //如上linkLast源码 linkLast(e);&#125; (3).remove()和remove(int index)操作 123456789101112131415161718192021222324252627/** * 这里遍历链表时区分null和非null值的查找，删除链表中第一个查到的节点 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; //使用unlink unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; 删除中间元素 (4).add(int index,E element)操作 12345678910public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) //见上面源码 linkLast(element); else //见上面源码 linkBefore(element, node(index));&#125; (5).get和set操作 12345678910111213141516171819202122232425262728293031//get,set 操作需要check index操作//get操作public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; //set操作public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; (5).indexof()操作 1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; 3. 总结: 从LinkedList中的层次结构来看，既有Deque又有Queue,而本篇是以实现List的双向链表来看源码，后面会有用Deque和Queue对比来看LinkedList。实现list,Deque和Queue的方法如下: LinkedList的set,get方法需要从尾或从头遍历链表[if (index &lt; (size &gt;&gt; 1))],add,addLast,addFirst,remove操作都非常快. Apache(org.apache.commons)下有一个TreeList底层用树来实现快速移动指针来达到快速查找的功能,时间复杂度O(log n),但占用内存大。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://www.yq194.top/tags/Java集合/"}]},{"title":"Java集合系列(二): ArrayList源码笔记","slug":"Java集合系列(二): ArrayList源码笔记","date":"2017-12-27T09:50:06.000Z","updated":"2018-01-06T17:31:42.000Z","comments":true,"path":"2017/12/27/Java集合系列(二): ArrayList源码笔记/","link":"","permalink":"http://www.yq194.top/2017/12/27/Java集合系列(二): ArrayList源码笔记/","excerpt":"1. ArrayList概述及层次结构(JDK1.8.0_131): ArrayList的底层是对象数组Object[]，可存储null 未指定初始化大小的默认容量大小是10，超过指定容量后ArrayList采用自动扩容，容量为原来的1.5倍(也就是增加了原来的50%)，1.5倍不大不小刚好，2，2.5。。。都会占用内存大 ArrayList的扩容采用的System.arraycopy()进行复制; 底层是数组决定的查找快，增删慢的特性。get（i），set（i，e） 的性能很高，而remove(i,e)，add(i,e)时需要通过System.arraycopy()复制来达移动数组的目的; ArrayList是非线程安全的，需要同步情况下可在构造时生成同步的List实例或采用java.util.concurrent下的并发类：List list = Collections.synchronizedList(new ArrayList(...));CopyOnWriteArrayList list = new CopyOnWriteArrayList();","text":"1. ArrayList概述及层次结构(JDK1.8.0_131): ArrayList的底层是对象数组Object[]，可存储null 未指定初始化大小的默认容量大小是10，超过指定容量后ArrayList采用自动扩容，容量为原来的1.5倍(也就是增加了原来的50%)，1.5倍不大不小刚好，2，2.5。。。都会占用内存大 ArrayList的扩容采用的System.arraycopy()进行复制; 底层是数组决定的查找快，增删慢的特性。get（i），set（i，e） 的性能很高，而remove(i,e)，add(i,e)时需要通过System.arraycopy()复制来达移动数组的目的; ArrayList是非线程安全的，需要同步情况下可在构造时生成同步的List实例或采用java.util.concurrent下的并发类：List list = Collections.synchronizedList(new ArrayList(...));CopyOnWriteArrayList list = new CopyOnWriteArrayList(); 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 2. ArrayList部分源码分析: ArrayList的使用非常多,在下面的分析中会对ArrayList中的set,add,remove等等操作进行源码分析 ArrayList成员变量及作用 123456789101112131415161718//默认数组容量private static final int DEFAULT_CAPACITY = 10;//共享的空数组实例private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//用来表示空ArrayList,当初始add时，用来区分EMPTY_ELEMENTDATA，以便于要扩充多少容量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//ArrayList的底层存储区，如果是空ArrayList构造时//使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素添加时会扩展成 DEFAULT_CAPACITY(10)transient Object[] elementData; //当前ArrayList中(数组中)的存储元素数量private int size;//极限容量，文档注释解释:一些VM在阵列中保留一些标题字。 尝试分配较大的数组可能会导致,OutOfMemoryError：请求的数组大小超过VM限制。private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; ArrayList构造函数 123456789101112131415161718//指定初始容量大小public ArrayList(int initialCapacity);//不指定容量，默认是10，在第一次add()操作时会指定public ArrayList();//将指定的c作为初始内容初始化数组public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) //这个构造函数贴出来主要是说明这个bug(已修复），原因是Object[]对象数组getClass()不一定是 //[Ljava.lang.Object,可以参考http://blog.csdn.net/huzhigenlaohu/article/details/51702737 讲解得很清楚 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; ArrayList的扩容和容量判断方法 自动扩容机制: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//将ArrayList的存储容量缩减实际容量,若实际容量为0，则改成默认大小public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;//如果有必要，增加ArrayList实例的容量，以确保它至少能容纳由最小容量参数指定的元素数量。public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)? 0: DEFAULT_CAPACITY; //上面的操作就是为了判断传入参数与默认容量比较，看是否要扩容 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;//还传入容量与默认容量的比较,取两者中大值private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;//与当前底层数组的容量进行比较，如果比默认容量大，就要扩容了private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;//真正扩容的操作private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //1.5倍的扩容体现在这里 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5扩充后，还要比传入容量小 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //就用传入容量与MAX_ARRAY_SIZE比 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //比MAX_ARRAY_SIZE还要大，再判断 newCapacity = hugeCapacity(minCapacity); //扩容，Arrays中的方法最后会调用System.arraycopy()本地方法进行数组复制 elementData = Arrays.copyOf(elementData, newCapacity);&#125;//最后只能取两个极限Integer.MAX_VALUE或 MAX_ARRAY_SIZE(正常情况肯定不会取到这里来)private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; ArrayList中的add,addAll添加操作 add操作 addAll操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //在数组屁股后面添加元素，必要时会扩容,返回true表示集合中值因这个操作而变化 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; //在指定位置添加元素，插入位置之后的所有元素全部后移，性能差，代价大 public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;//在原数组屁股后添加一个集合的所有元素public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; //从指定index插入一个集合c的所有元素，同样性能差，代价大 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; //这里modCount来自于AbstractList，用来标记并发修改，用 //for-each时迭代会出现ConcurrentModificationException异常.同时需要注意的是 //AbstractList是用来最大限度地减少了实现由“随机访问”数据存储（如数组）支持的接口所需的工作，相应的具体实现只要 //需要或有更好的方式会去实现，不然就是复用 ArrayList中的remove操作 remove操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//remove指定位置操作，返回被remove的值 public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //数组扩容 System.arraycopy(elementData, index+1, elementData, index, numMoved); //清空移动后的位置内容，方便GC elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; //删除指定元素 public boolean remove(Object o) &#123; //如果o为null，删除第一个为null的元素 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //真正的删除操作 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; ArrayList中的查找indexof操作 123456789101112131415161718192021222324252627282930//查找操作，查找第一次出现的位置 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;//删除一定范围内的元素，从fromIndex到toIndexprotected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125;//lastIndexOf()与indexOf()相差不大，反向查找，不贴代码了 3. ArrayList总结: ArrayList底层的数据结构决定的ArrayList的特性，从数据结构来看就看出的哪些操作性能差，哪些操作性能好，应当在不同的场合使用恰当的集合类才是最佳的。除了上面的一些操作，还有一些如ListIterator listIterator()(List特有的迭代，用的少一点); Iterator iterator();等方法没有解析，代码太长，可以直接去参考源码。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://www.yq194.top/tags/Java集合/"}]},{"title":"Java I/O流(一):字节流","slug":"Java-I-O流-一-字节流","date":"2017-11-07T02:04:14.000Z","updated":"2018-01-04T02:35:53.000Z","comments":true,"path":"2017/11/07/Java-I-O流-一-字节流/","link":"","permalink":"http://www.yq194.top/2017/11/07/Java-I-O流-一-字节流/","excerpt":"Java I/O 流(一) : 字节流 Java中流的原理: 可以把Java中IO(从文件、网络等等读写数据都是IO)想像成连接着程序和数据源之间的管道，我们既可以通过管道把数据输出到数据源，也可以通过管道将数据从数据源读入。(管道中流的就是01010101… 这样的字节数据) 将管道中流进行过滤、包装、转换等操作就产生一系列的装饰流。 Java中的IO流是指字节数据（bytes data）从源对象对按顺序流向目标对象的一种流动形式 当说输入流输出流的时候是站在程序的角度来说的。 输入流:程序将数据从数据源(网络、文件等)读入到程序中(实际是内存中) 输出流:程序将数据从程序(内存)中输出(写入)到数据源(网络、文件等)","text":"Java I/O 流(一) : 字节流 Java中流的原理: 可以把Java中IO(从文件、网络等等读写数据都是IO)想像成连接着程序和数据源之间的管道，我们既可以通过管道把数据输出到数据源，也可以通过管道将数据从数据源读入。(管道中流的就是01010101… 这样的字节数据) 将管道中流进行过滤、包装、转换等操作就产生一系列的装饰流。 Java中的IO流是指字节数据（bytes data）从源对象对按顺序流向目标对象的一种流动形式 当说输入流输出流的时候是站在程序的角度来说的。 输入流:程序将数据从数据源(网络、文件等)读入到程序中(实际是内存中) 输出流:程序将数据从程序(内存)中输出(写入)到数据源(网络、文件等) ​(图片来源于网络) Java流的分类: 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 按流向可以分为：输入流和输出流 按处理数据单位大小的不同可以分为：字节流和字符流 按处理功能的不同可以分为：节点流(又叫低级流) 和 处理流(又叫高级流，包装流) ​ 字节流将0101001二进制数据以字节(byte)的方式来读，1个字节(byte)是8位(bit)，读的时候按字节来读； ​ 字符流是以字符为单位读，1个字符是2个字节； ​ 节点流就是直接读数据源里面的数据，或者是直接往数据源里面写入数据,用来读取原始的数据； ​ 处理流是包在别的流上面的流，相当于是包到别的管道上面的管道。 下面是InputStream和OutputStream基本api: 1234567891011121314151617181920212223InputStream(输入流): • 主要方法 abstract int read() //读取一个字节数据， 并返回读到的数据，如果返回-1，表示读到了输入流的末尾。 int read(byte[] b) //将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。 int read(byte[] b, int off, int len)//将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。off 指定在数组b中存放数据的起始偏移位置;len指定读取的最大字节数。 • 其它方法 long skip(long n) //在输入流中跳过n个字节，并返回实际跳过的字节数。 int available() //返回在不发生阻塞的情况下，可读 取的字节数。 void close() //关闭输入流，释放和这个流相关的系统资源。 void mark(int readlimit) //在输入流的当前位置放 置一个标记，如果读取的字节数多于readlimit设置的值， 则流忽略这个标记。 void reset() //返回到上一个标记。 boolean markSupported() //测试当前流是否支持mark和reset方法。如果支持，返回true，否则返回false OutputStream(输出流): • 主要方法 abstract void write(int b) //往输出流中写入一个字节。 void write(byte[] b) //往输出流中写入数组b中的所有字节。 void write(byte[] b, int off,int len) //往输出流中写入数组b中从偏移量off开始的len个字节的数据 • 其它方法 void flush() //刷新输出流，强制缓冲区中的输出字节被写出。 void close() //关闭输出流，释放和这个流相关的系统资源。 InputStream及OutputStream继承体系详解: ​ 在详解之前先放上两张图来整体了解InputStream和OutputStream: ​ InputStream体系结构图(常用类,其中StringBufferInputStream已废弃): ​ ​ OutputStream体系结构图(常用类): ​ ​ 从两张继承体系图可以简单理解： ​ (1) 处理不同的数据来源时，按以下方式来理解比较清晰： ​ 想要处理文件时，来一个子类： FileOutputStream和FileInputStream ​ 想要处理对象时，来一个子类：ObjectInputStream和ObjectOutputStream ​ 想要处理线程间通信时，来一个子类：PipeInputStream和PipedOutputStream ​ 想要处理字节数组时，来一个子类：ByteArrayInputStream和ByteOutputStream ​ 最后，想要多个流进行合并，来一个子类：SequenceInputStream ! 节点流和处理流： 下面是对节点流(包含输入流和输出流)的详细说明 : 1). 节点流 ​ 节点流:从特定的地方读写的流类，例如:磁盘或一块内存区域。 处理类型 字节流 字符流 File(文件) FileInputStream ,FileOutputStream FileReader,FileWriter Mermory Array(内存数组) ByteArrayInputStream, ByteArrayOutputStream CharArrayReader,CharArrayWriter Memory String(内存字符串) ———————————————– StringReader,StringWriter Pipe(管道) PipeInputStream,PipeOutputStream PipeReader,PipeWriter ​ • FileInputStream 和 FileOutputStream ==&gt; 用来处理文件: 123456789101112131415161718192021FileInputStream类创建一个能从文件读取字节的InputStream 类，它的两个常用的方法如下:- FileInputStream(String filepath) throw FileNotFoundException //构造方法- FileInputStream(File fileObj) throw FileNotFoundException //构造方法- FileInputStream(FileDescriptor fdObj) //FileDescriptor为文件描述(封装了不同底层文件系统的统一文件句柄)- int read( ) throws IOException //与InputStream的read一致- FileChannel getChannel() //返回与这个流相关的唯一的FileChannel- FileDescriptor getDF() //返回文件句柄 FileOutputStream类创建一个能从文件读取字节的输出流 类，它的两个常用的方法如下:- FileOutputStream(File file) - FileOutputStream(File file, boolean append)//append指示了在对文件读写时是否追加- FileOutputStream(FileDescriptor fdObj)- FileOutputStream(String name)- FileOutputStream(String name, boolean append)- void write(byte[] b)- void write(byte[] b, int off, int len) //写字节数组，off ~ len- void write(int b)//写指定byte​其它的skip(),available(),close()方法与InputStream中api含意基本相同. ​FileInputStream和FileOutputStream用法: 123456789101112131415161718192021/*** FileInputStream 的示例:* 读取某一文件，并将文件输出生成另一新的文件(或输出每一次读取到的字节并打印)* @throws Exception */public static void test() throws Exception &#123; InputStream is = new FileInputStream(new File(\"/Users/leinl/Desktop/aa.gif\")); //InputStream is = new FileInputStream(\"/Users/leinl/Desktop/aa.gif\"); OutputStream os = new FileOutputStream(\"test.gif\"); byte[] buff = new byte[1024]; int length = 0; int i = 0; while ((length = is.read(buff)) != -1)&#123; //String s = new String(buff,0,length); os.write(buff,0,length); i++; &#125; System.out.println(\"使用buff读了\" + i + \"次\"); os.close(); is.close(); &#125; ​ • ByteArrayInputStream 和 ByteArrayOutputStream ==&gt; 用来处理字节数组: 1234567891011121314151617ByteArrayInputStream是把字节数组当成源的输入流,基内部代码实现是维护了一个用于缓存的buff字节数组:- ByteArrayInputStream(byte[] buf) //构造方法- ByteArrayInputStream(byte[] buf, int offset, int length) //构造方法- int read() //从这个流中读取下一个字节(该类中保存了上一个次读取的位置)- int read(byte[] b, int off, int len) //将数据从这个输入流中读取到一个字节数组中ByteArrayOutputStream调用该输出流的write()方法都会把数据写入到该流中的缓存数组中:- ByteArrayOutputStream() //创建一个新字节数组输出流，默认数组大小32- ByteArrayOutputStream(int size)//创建指定大小的字节数组输出流- int size() //返回当前流中buff的大小- byte[] toByteArray() //产生一个的新的字节数组,Arrays.copy来的- String toString() //产生新的字符串，串\b内容来自于流的byte[]- String toString(String charsetName) //生成指定字符集的新字符串- void write(byte[] b, int off, int len) //将off~len的byte[]写入到这个输出流中- void write(int b) //写指定字节到该流中- void writeTo(OutputStream out) //将out流中的字符写入到该中，相当于调用out.write(buf, 0, count) ​​ByteArrayInputStream和ByteArrayOutputStream用法: 12345678910111213141516171819202122232425262728293031/*** ByteArrayInputStream 和 ByteArrayOutputStream测试*/public static void test() throws Exception&#123; String str = \"Hello ByteArrayInputStream!!!!\"; ByteArrayInputStream is = new ByteArrayInputStream(str.getBytes()); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int ch; while ((ch = is.read()) != -1)&#123; int upperCase = Character.toUpperCase(ch); baos.write(upperCase); &#125; byte[] bytes1 = \"哈哈\".getBytes(); //write(buff,off,len) baos.write(bytes1,0,bytes1.length); //write(buff) baos.write(\"嘿嘿\".getBytes()); byte[] bytes = baos.toByteArray(); System.out.println(baos.toString(\"UTF-8\"));//HELLO BYTEARRAYINPUTSTREAM!!!!哈哈嘿嘿 System.out.println(new String(bytes));//HELLO BYTEARRAYINPUTSTREAM!!!!哈哈嘿嘿 System.out.println(baos.size());//84 //write(outputStream os) baos.writeTo(baos); System.out.println(baos.toString()); is.close(); baos.close(); &#125; ​ • PipeInputStream 和 PipeOutputStream ==&gt; 用来处理线程间的通信 管道流，用于线程间的通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。要使管道流有用，必须同时构造管道输入流和管道输出流。 ​ ​ (图片来自于网络) 从api文档注释来看: 管道输入流应该连接到管道输出流;管道输入流提供了写入管道输出流的数据字节,两个流应分别用两个线程来分别使用使用这两个对象,单个线程操作两个流可能会导致死锁。管道输入流包含缓冲区，提供读写分离。如果为连接的管道输出流提供数据字节的线程已经不再存在，那么就说明该管道被破坏。 1234567891011121314151617181920 &apos;PipedInputStream构造方法:&apos; ​ - PipedInputStream() //创建一个还未连接的PipedInputStream​ ​- PipedInputStream(int pipeSize) //创建一个指定大小缓冲区的PipedInputStream(缓冲区用的是byte[])​ - ​PipedInputStream(PipedOutputStream src) //创建一个PipedInputStream以便于连接传入的输出流src - PipedInputStream(PipedOutputStream src, int pipeSize) //创建指定大小缓冲区的PipedInputStream以便 连接到输出流src​ - int available() ​ - void close() ​ - void connect(PipedOutputStream src) //连接输出流​ - int read() int read(byte[] b, int off, int len)​ &apos;PipedOutputStream构造方法:&apos;​ - PipedOutputStream()​ - PipedOutputStream(PipedInputStream snk) //创建输出流以便连接传入的输入流snk​ - void close()​ - void connect(PipedInputStream snk) //连接输入流​ - void flush()​ - void write(byte[] b, int off, int len)​ - void write(int b) ​ PipeInputStream 和 PipeOutputStream具体使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class PipedInputStreamTest &#123; public static void main(String[] args) &#123; Send send = new Send(); Receive receive = new Receive(); PipedInputStream pi = receive.getPi(); PipedOutputStream pos = send.getPos(); try &#123; //连接 pos.connect(pi); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //开启线程 send.start(); receive.start(); &#125;&#125;class Receive extends Thread&#123; private PipedInputStream pi = new PipedInputStream(); @Override public void run() &#123; try &#123; byte[] buf = new byte[1024]; int len = pi.read(buf); System.out.println(\"接收消息,消息接收者Receive:\" + new String(buf,0,len)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pi.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public PipedInputStream getPi() &#123; return pi; &#125;&#125;class Send extends Thread&#123; PipedOutputStream pos = new PipedOutputStream(); @Override public void run() &#123; try &#123; String str = \"hello the world\"; pos.write(str.getBytes()); System.out.println(\"发送消息,消息来源于Send:\" + str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public PipedOutputStream getPos() &#123; return pos; &#125;&#125; ​ 以上就是几个常见的节点流的详细介绍，下面是处理流介绍: 2). 处理流 ​ . 处理流:”连接”在已存在的流(节点流或处理流)上，通过对数据的处理为程序提供更强大的功能的流类。 处理类型 字节流 字符流 Buffering BufferedInputStream ,BufferedOutputStream BufferedReader,BufferedWriter Filtering FilterInputStream,FilterOutputStream FilterReader,FilterWriter Converting between Bytes And Character ———————————————– InputStreamReader,OutputStreamWriter Object Serialization ObjectInputStream,ObjectOutputStream —————————————— Data Conversion DataInputStream,DataOutputStream —————————————— Counting LineNumberInputStream LineNumberReader Peaking PushbackInputStream PushbackReader Printing PrintStream PrintWriter a). 第一种处理流：对象流• ObjectInputStream 和 ObjectOutputStream ==&gt; 用来处理被序列化的对象 12345-ObjectInputStream(InputStream in) //构造方法​一系列的read方法如:readInt(),readBoolean()…用从in流中的读取各种对象。​-ObjectOutputStream(OutputStream out) //构造方法 ​ 其他公有方法可与ObjectInputStream类比。具体使用见如下代码: 12345678910111213141516171819202122232425262728293031323334public static void test() throws Exception&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"output.txt\"))); byte[] str = \" the world!\".getBytes(); //void write(byte[] buf) oos.write(str); //void write(byte[] buf,int off,int len) oos.write(str,0,str.length); //void write(double val) oos.writeDouble(2.0D); //void write(int val) oos.write(20); oos.writeByte(112); oos.writeChar('C'); oos.writeBoolean(false); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"output.txt\"))); byte[] readBytes = new byte[str.length]; ois.read(readBytes); System.out.println(new String(readBytes)); ois.read(readBytes); System.out.println(new String(readBytes)); double v = ois.readDouble(); System.out.println(v); byte i = ois.readByte(); System.out.println(i); byte b = ois.readByte(); System.out.println(b); char c = ois.readChar(); System.out.println(c); boolean b1 = ois.readBoolean(); System.out.println(b1); ois.close(); &#125; b). 第二种处理流：缓冲流​ • SequenceInputStream ==&gt; 用来处理多个流(数据源)的连接 缓冲输入/输出是一个非常普通的性能优化。Java 的BufferedInputStream类允许把任何InputStream 类“包装”成缓冲流,对数据读取提供了缓冲的功能并使它的性能提高 123456​ - public SequenceInputStream(InputStream s1,InputStream s2) //构造方法，提供一个SequenceInputStream，其提供字节读入的来源是s1,s2,初始化时按先s1再s2的顺序。 - public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) //构造方法，按顺序读取Enum中的流集合从而初始化一个SequenceInputStream​两个主要的read方法: - int read() //读下一个字节​ - int read(byte[] b, int off, int len)//读指定buf的off-len长度的byte[] 1234567891011121314public static void test() throws Exception&#123; Vector&lt;InputStream&gt; vector = new Vector&lt;&gt;(2); vector.add(new FileInputStream(new File(\"output.txt\"))); vector.add(new ByteArrayInputStream(\"hello\".getBytes())); Enumeration&lt;InputStream&gt; elements = vector.elements(); SequenceInputStream sis = new SequenceInputStream(elements); byte[] buff = new byte[1024]; int len; FileOutputStream fos = new FileOutputStream(new File(\"output2.txt\")); while ((len = sis.read(buff)) != -1)&#123; fos.write(buff,0,len); &#125; fos.close(); &#125; ​","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.yq194.top/categories/Java基础/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://www.yq194.top/tags/IO/"}]},{"title":"mysql join 详解","slug":"Mysql join types","date":"2017-05-13T14:44:21.000Z","updated":"2018-01-04T02:36:35.000Z","comments":true,"path":"2017/05/13/Mysql join types/","link":"","permalink":"http://www.yq194.top/2017/05/13/Mysql join types/","excerpt":"SQL JOIN是从两个或多个数据库表中检索数据的方法。本文介绍了特定SQL联接中的数据的基本概述。理解SQL连接的流行方式是使用维恩图进行可视化，因此每个示例都有相应的维恩图，适当的SELECT语句和结果表。本文参考链接: ​ https://dev.mysql.com/doc/refman/5.6/en/join.html mysql官方文档 ​ https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins codeproject文章 ​ https://academy.vertabelo.com/blog/sql-joins/ mysql joins ​ http://stevestedman.com/2015/03/mysql-join-types-poster/ 某博客整理的join图 ​ http://stackoverflow.com/questions/5706437/whats-the-difference-between-inner-join-left-join-right-join-and-full-join/6188334#6188334 stackoverflow","text":"SQL JOIN是从两个或多个数据库表中检索数据的方法。本文介绍了特定SQL联接中的数据的基本概述。理解SQL连接的流行方式是使用维恩图进行可视化，因此每个示例都有相应的维恩图，适当的SELECT语句和结果表。本文参考链接: ​ https://dev.mysql.com/doc/refman/5.6/en/join.html mysql官方文档 ​ https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins codeproject文章 ​ https://academy.vertabelo.com/blog/sql-joins/ mysql joins ​ http://stevestedman.com/2015/03/mysql-join-types-poster/ 某博客整理的join图 ​ http://stackoverflow.com/questions/5706437/whats-the-difference-between-inner-join-left-join-right-join-and-full-join/6188334#6188334 stackoverflow 一、一般来说，大致分为如下四类: INNER JOIN (内连接) OUTER [LEFT | RIGHT | FULL] JOIN （外连接） NATURAL JOIN (自然连接) CROSS JOIN （交叉连接） (mysq中有TRAIGHT_JOIN) 值得注意的是内连接和外连接后接的条件操作符可以是”&gt;”,”&lt;”,”=”,”&gt;=”,”&lt;=” 但是,mysql官方文档中是这样写的: ​ MySQL对SELECT语句的table_references(下面的引用)部分和多表DELETE和UPDATE语句支持JOIN语法(具体如下 )： 1234567891011121314151617181920212223242526272829303132333435363738394041table_references: escaped_table_reference [, escaped_table_reference] ...escaped_table_reference: table_reference | &#123; OJ table_reference &#125;table_reference: table_factor | join_tabletable_factor: tbl_name [PARTITION (partition_names)] [[AS] alias] [index_hint_list] | table_subquery [AS] alias | ( table_references )join_table: table_reference [INNER | CROSS] JOIN table_factor [join_condition] | table_reference STRAIGHT_JOIN table_factor | table_reference STRAIGHT_JOIN table_factor ON conditional_expr | table_reference &#123;LEFT|RIGHT&#125; [OUTER] JOIN table_reference join_condition | table_reference NATURAL [&#123;LEFT|RIGHT&#125; [OUTER]] JOIN table_factorjoin_condition: ON conditional_expr | USING (column_list)index_hint_list: index_hint [, index_hint] ...index_hint: USE &#123;INDEX|KEY&#125; [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list]) | IGNORE &#123;INDEX|KEY&#125; [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list) | FORCE &#123;INDEX|KEY&#125; [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)index_list: index_name [, index_name] ... 从上来看，主要两个方面: ​ 1.mysql中会有以下join出现: ​ INNER JOIN( 内连接),CROSS JOIN(交叉连接),这两个可以不带ON ​ STRAIGHT_JOIN(直接连接,可带ON也可以不带ON), ​ LEFT|RIGHT|FULL [OUTER] JOIN 左连接或左外连接或全连接, ​ NATURAL [{LEFT|RIGHT} [OUTER]] JOIN 自然连接(左|右) ​ 2.mysql中可以使用USING来处理像ON这样的条件，下面会详细说明。 二、用实例来说明这些JOIN的区别:​ 首先定两张表如下: 12345678 TableB TableA+------+--------+ +------+--------+| b_id | b_name | | a_id | a_name |+------+--------+ +------+--------+| A | apple | | 1 | apple || B | banana | | 2 | orange || C | NULL | | 3 | NULL |+------+--------+ +------+--------+ ​ （一）外连接(左外连接，右外连接，完整外连接) LEFT JOIN: 12345678select * from TableA left join TableB on TableA.a_name = TableB.b_name+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || 2 | orange | NULL | NULL || 3 | NULL | NULL | NULL |+------+--------+------+--------+ left join 以左表主基准,返回左表的全部记录，如果on后面条件匹配，会带出右表的匹配记录,右表中不匹配的列全是NULL。下面为图解: ​ (不难看出:连接出来不等的右边会取一条null记录来给左表对应) {0}. RIGHT JOIN 12345678SELECT * FROM test.TableA RIGHT JOIN test.TableB ON test.TableA.a_name = test.TableB.b_name;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || NULL | NULL | B | banana || NULL | NULL | C | NULL |+------+--------+------+--------+ 与LEFT JOIN相反 : ![2.pic](/images/2.pic.jpg) {0}. FULL JOIN（不能带ON条件） 1234567891011121314select * from TableA full join TableB;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || 1 | apple | B | banana || 1 | apple | C | NULL || 2 | orange | A | apple || 2 | orange | B | banana || 2 | orange | C | NULL || 3 | NULL | A | apple || 3 | NULL | B | banana || 3 | NULL | C | NULL |+------+--------+------+--------+ 外连接的full join 及自然连接的natural join不能带on条件，cross join可以带on条件 如果三者都不带条件的情况下就全连接即笛卡尔集！ ​ #### （二）内连接(INNER JOIN) {0}. INNER JOIN 123456select * from TableA inner join TableB on TableA.a_name = TableB.b_name+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple |+------+--------+------+--------+ inner join会根据条件匹配找到条件相等的列，它并不像上面的left join 和right join一样返回左或右边表的所有记录。 （三）交叉连接(CROSS JOIN) 5.CROSS JOIN（通常的笛卡尔集） 1234567891011121314select * from TableA cross join TableB;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 1 | apple | A | apple || 1 | apple | B | banana || 1 | apple | C | NULL || 2 | orange | A | apple || 2 | orange | B | banana || 2 | orange | C | NULL || 3 | NULL | A | apple || 3 | NULL | B | banana || 3 | NULL | C | NULL |+------+--------+------+--------+ 就是依次把左表的每一列去与右所有列对应，相当于A:2x3, B:2x3 == &gt; 4*9 ; cross join不带条件就笛卡尔集，带条件就会根据条件去掉相应的列!!! （四）自然连接(NATURAL JOIN),应该可以直接分类到外连接包括为左自然连接和右自然连接(需要注意：自然连接不带ON条件) NATURAL JOIN 这个就不用列出了，就是笛卡尔集，也是full join NATRUAL LEFT JOIN|NATRUAL LEFT JOIN natural join分左右应该只是连接时以左或右为基准去连接，实际上连接 的结果与natural join的结果一样。（感觉这个自然连接意义不大） ​ 二、下面再来讨论一些比较特殊但可能很有用的JOINS LEFT JOIN EXCLUDING INNER JOIN 12345678SELECT * FROM TableA LEFT JOIN test.TableB ON TableA.a_name = TableB.b_nameWHERE TableB.b_name IS NULL;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| 2 | orange | NULL | NULL || 3 | NULL | NULL | NULL |+------+--------+------+--------+ 返回的结果中是左表的结果(不包含两表的交集‘) Right Excluding JOIN1234567mysql&gt; SELECT * FROM TableA RIGHT JOIN TableB ON TableA.a_name = TableB.b_name WHERE TableA.a_name IS NULL;+------+--------+------+--------+| a_id | a_name | b_id | b_name |+------+--------+------+--------+| NULL | NULL | B | banana || NULL | NULL | C | NULL |+------+--------+------+--------+ 返回的结果是右表的集(除去了两表的交集) Outer Excluding JOIN123SELECT * FROM TableA JOIN test.TableB ON TableA.a_name = TableB.b_name WHERE TableA.a_name IS NULL OR TableB.b_name IS NULL;等价于: (Right Excluding JOIN) UNION (LEFT JOIN EXCLUDING INNER JOIN) ​ 返回的是两表的非交集,这里没有数据主要是我表的数据设置有点问题，不过从 https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins 这篇文章及例子可以了解。 最后mysql中有一个STRAIGHT_JOIN,它的表现与INNER JOIN相同，详细请看下面这个博客 : ​ 【MySQL】性能优化之 straight_join 三、总结 :​ 通过以上的分类可以了解到sql join的具体分类及使用,通过整理应该可以更加好的了解sql join以及mysql join的具体形式及用法 .下面放上盗来的图）)： ​ 图1： ​ 图2：下图还包含3表连接的状态 : 注:图中部分出处都有地址注明，请参见文章开头","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.yq194.top/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.yq194.top/tags/MySQL/"}]}]}